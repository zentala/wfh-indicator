# Device Mock - Testing Strategy

## ğŸ§ª Strategia Testowania

### Testy Jednostkowe (Unit Tests)

#### LEDController Tests
```typescript
describe('LEDController', () => {
  test('should set color correctly', () => {
    const led = new LEDController();
    led.setColor('#FF0000');
    expect(led.getStatus().color).toBe('#FF0000');
  });

  test('should set brightness correctly', () => {
    const led = new LEDController();
    led.setBrightness(80);
    expect(led.getStatus().brightness).toBe(80);
  });

  test('should validate brightness range', () => {
    const led = new LEDController();
    expect(() => led.setBrightness(150)).toThrow();
    expect(() => led.setBrightness(-10)).toThrow();
  });
});
```

#### WiFiManager Tests
```typescript
describe('WiFiManager', () => {
  test('should start WebSocket server', async () => {
    const wifi = new WiFiManager({ port: 8080 });
    await wifi.start();
    expect(wifi.isRunning()).toBe(true);
  });

  test('should handle client connections', () => {
    const wifi = new WiFiManager({ port: 8080 });
    // Mock WebSocket connection
    expect(wifi.getConnectedClients()).toHaveLength(1);
  });

  test('should broadcast messages', () => {
    const wifi = new WiFiManager({ port: 8080 });
    const message = { type: 'test', data: 'test' };
    wifi.broadcast(message);
    // Verify message was sent
  });
});
```

#### ButtonHandler Tests
```typescript
describe('ButtonHandler', () => {
  test('should handle single press', () => {
    const button = new ButtonHandler();
    const callback = jest.fn();
    button.setPressCallback(callback);
    button.handlePress('single');
    expect(callback).toHaveBeenCalledWith('single');
  });

  test('should handle long press', () => {
    const button = new ButtonHandler();
    const callback = jest.fn();
    button.setPressCallback(callback);
    button.handlePress('long');
    expect(callback).toHaveBeenCalledWith('long');
  });

  test('should debounce rapid presses', () => {
    const button = new ButtonHandler();
    const callback = jest.fn();
    button.setPressCallback(callback);

    // Rapid presses
    button.handlePress('single');
    button.handlePress('single');
    button.handlePress('single');

    // Should only trigger once due to debouncing
    expect(callback).toHaveBeenCalledTimes(1);
  });
});
```

### Testy Integracyjne (Integration Tests)

#### Device Communication Flow
```typescript
describe('Device Communication Flow', () => {
  test('should handle status update flow', async () => {
    const mock = new DeviceMock({ testMode: true });
    await mock.start();

    // Simulate status update from tray app
    await mock.wifiManager.handleMessage({
      type: 'status_update',
      status: WorkStatus.AVAILABLE,
      timestamp: Date.now()
    });

    // Verify LED changed color
    const ledStatus = mock.ledController.getStatus();
    expect(ledStatus.color).toBe('#00FF00'); // Green for AVAILABLE
  });

  test('should handle ask to enter flow', async () => {
    const mock = new DeviceMock({ testMode: true });
    await mock.start();

    // Simulate button press
    await mock.buttonHandler.handlePress('single');

    // Verify ask to enter request was sent
    const sentMessages = mock.wifiManager.getSentMessages();
    expect(sentMessages).toContainEqual(
      expect.objectContaining({
        type: 'ask_to_enter',
        urgency: 'normal'
      })
    );
  });
});
```

#### Serial Communication Tests
```typescript
describe('Serial Communication', () => {
  test('should handle WiFi credentials', async () => {
    const mock = new DeviceMock({ testMode: true });
    await mock.start();

    const credentials = {
      ssid: 'TestWiFi',
      password: 'test123',
      security: 'WPA2'
    };

    await mock.serialUtils.receiveData(credentials);

    // Verify WiFi connection attempt
    expect(mock.wifiManager.getConnectionAttempts()).toContainEqual(
      expect.objectContaining({
        ssid: 'TestWiFi',
        success: true
      })
    );
  });
});
```

### Testy End-to-End (E2E Tests)

#### Complete Pairing Flow
```typescript
describe('Complete Pairing Flow', () => {
  test('should complete pairing process', async () => {
    const mock = new DeviceMock({ testMode: true });
    await mock.start();

    // 1. Receive WiFi credentials
    await mock.testController.receiveSerialData({
      ssid: 'TestWiFi',
      password: 'test123',
      security: 'WPA2'
    });

    // 2. Verify connection attempt
    expect(mock.wifiManager.isConnected()).toBe(true);

    // 3. Verify green LED confirmation
    const ledStatus = mock.ledController.getStatus();
    expect(ledStatus.color).toBe('#00FF00'); // Green

    // 4. Verify device is paired
    expect(mock.getStatus().paired).toBe(true);
  });
});
```

#### Ask to Enter Flow
```typescript
describe('Ask to Enter Flow', () => {
  test('should handle ask to enter request', async () => {
    const mock = new DeviceMock({ testMode: true });
    await mock.start();

    // 1. Send ask to enter request
    await mock.testController.sendAskToEnterRequest('normal');

    // 2. Verify request was sent
    const sentMessages = mock.wifiManager.getSentMessages();
    expect(sentMessages).toContainEqual(
      expect.objectContaining({
        type: 'ask_to_enter',
        urgency: 'normal'
      })
    );

    // 3. Simulate response from tray app
    await mock.wifiManager.handleMessage({
      type: 'ask_to_enter_response',
      deviceId: 'device-1',
      response: 'yes',
      timestamp: Date.now()
    });

    // 4. Verify response was received
    const lastResponse = await mock.testController.getLastResponse();
    expect(lastResponse).toBe('yes');
  });
});
```

### Testy WydajnoÅ›ciowe (Performance Tests)

#### Response Time Tests
```typescript
describe('Performance Tests', () => {
  test('should respond to status updates within 100ms', async () => {
    const mock = new DeviceMock({ testMode: true });
    await mock.start();

    const startTime = Date.now();

    await mock.wifiManager.handleMessage({
      type: 'status_update',
      status: WorkStatus.AVAILABLE,
      timestamp: Date.now()
    });

    const responseTime = Date.now() - startTime;
    expect(responseTime).toBeLessThan(100);
  });

  test('should handle multiple rapid status changes', async () => {
    const mock = new DeviceMock({ testMode: true });
    await mock.start();

    const statuses = [
      WorkStatus.AVAILABLE,
      WorkStatus.FOCUSED,
      WorkStatus.ON_CALL,
      WorkStatus.AWAY
    ];

    for (const status of statuses) {
      await mock.wifiManager.handleMessage({
        type: 'status_update',
        status,
        timestamp: Date.now()
      });
    }

    // Verify all status changes were processed
    const ledStatus = mock.ledController.getStatus();
    expect(ledStatus.color).toBe('#0000FF'); // Blue for AWAY (last status)
  });
});
```

### Testy BÅ‚Ä™dÃ³w (Error Tests)

#### Network Error Handling
```typescript
describe('Error Handling', () => {
  test('should handle WebSocket connection errors', async () => {
    const mock = new DeviceMock({ testMode: true });
    await mock.start();

    // Simulate connection error
    mock.wifiManager.simulateError(new Error('Connection failed'));

    // Verify error recovery
    expect(mock.wifiManager.isReconnecting()).toBe(true);
  });

  test('should handle invalid message format', async () => {
    const mock = new DeviceMock({ testMode: true });
    await mock.start();

    // Send invalid message
    await mock.wifiManager.handleMessage({
      type: 'invalid_type',
      data: 'invalid_data'
    });

    // Verify error was logged
    expect(mock.logger.getErrors()).toContainEqual(
      expect.objectContaining({
        type: 'invalid_message_format'
      })
    );
  });
});
```

## ğŸ“Š Metryki Testowania

### Pokrycie Testami
- **Unit Tests**: >90% pokrycie
- **Integration Tests**: >80% pokrycie
- **E2E Tests**: Wszystkie krytyczne Å›cieÅ¼ki

### Performance Metrics
- **Response Time**: <100ms dla status updates
- **Memory Usage**: <50MB dla mocka
- **CPU Usage**: <10% podczas normalnej pracy

### Reliability Metrics
- **Test Stability**: >95% przechodzÄ…cych testÃ³w
- **Error Recovery**: 100% testowanych scenariuszy bÅ‚Ä™dÃ³w
- **Memory Leaks**: 0 wykrytych wyciekÃ³w pamiÄ™ci

## ğŸ› ï¸ NarzÄ™dzia Testowe

### Jest Configuration
```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/types/**/*.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    }
  }
};
```

### Test Utilities
```typescript
// tests/utils/mockHelpers.ts
export class MockTestHelpers {
  static createMockDevice(options?: Partial<DeviceMockOptions>): DeviceMock {
    return new DeviceMock({
      testMode: true,
      debug: false,
      ...options
    });
  }

  static async waitForLEDChange(mock: DeviceMock, expectedColor: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('LED color change timeout'));
      }, 5000);

      const checkColor = () => {
        if (mock.ledController.getStatus().color === expectedColor) {
          clearTimeout(timeout);
          resolve();
        } else {
          setTimeout(checkColor, 100);
        }
      };

      checkColor();
    });
  }
}
```

## ğŸš€ Continuous Integration

### GitHub Actions Workflow
```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm install -g pnpm
      - run: pnpm install
      - run: pnpm test
      - run: pnpm test:integration
      - run: pnpm test:e2e
      - run: pnpm build
```

---

**Note**: Ta strategia testowania zapewnia wysokÄ… jakoÅ›Ä‡ kodu i niezawodnoÅ›Ä‡ mocka urzÄ…dzenia.
