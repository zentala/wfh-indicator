# Device Mock - Deployment & CI/CD

## üöÄ Deployment Strategy

### Development Environment

#### Local Development
```bash
# Instalacja zale≈ºno≈õci
cd emulator
pnpm install

# Development mode
pnpm dev

# Test mode
pnpm test:mock

# Build
pnpm build
```

#### Environment Variables
```bash
# .env.local
MOCK_PORT=8080
MOCK_SERIAL_PORT=/dev/ttyUSB0
MOCK_TEST_MODE=false
MOCK_DEBUG=true
MOCK_BATTERY_LEVEL=100
MOCK_CHARGING=false
```

### Production Environment

#### Docker Deployment
```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# Install pnpm
RUN npm install -g pnpm

# Copy package files
COPY package.json pnpm-lock.yaml ./

# Install dependencies
RUN pnpm install --frozen-lockfile

# Copy source code
COPY . .

# Build application
RUN pnpm build

# Expose port
EXPOSE 8080

# Start application
CMD ["pnpm", "start"]
```

#### Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  device-mock:
    build: .
    ports:
      - "8080:8080"
    environment:
      - MOCK_PORT=8080
      - MOCK_TEST_MODE=false
      - MOCK_DEBUG=false
    restart: unless-stopped
```

## üîÑ CI/CD Pipeline

### GitHub Actions

#### Main Workflow
```yaml
# .github/workflows/main.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Install dependencies
        run: pnpm install

      - name: Run linting
        run: pnpm lint

      - name: Run tests
        run: pnpm test

      - name: Run integration tests
        run: pnpm test:integration

      - name: Build application
        run: pnpm build

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
```

#### E2E Tests Workflow
```yaml
# .github/workflows/e2e.yml
name: E2E Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Install dependencies
        run: |
          cd emulator && pnpm install
          cd ../tray-app && pnpm install

      - name: Start mock device
        run: |
          cd emulator
          pnpm start:mock &
          sleep 5

      - name: Run E2E tests
        run: |
          cd tray-app
          pnpm test:e2e
```

### Automated Testing

#### Unit Tests
```bash
# Run unit tests
pnpm test

# Run with coverage
pnpm test:coverage

# Run specific test file
pnpm test -- tests/unit/ledController.test.ts
```

#### Integration Tests
```bash
# Run integration tests
pnpm test:integration

# Run with specific environment
MOCK_TEST_MODE=true pnpm test:integration
```

#### E2E Tests
```bash
# Run E2E tests with tray app
pnpm test:e2e

# Run specific E2E test
pnpm test:e2e -- tests/pairing.spec.ts
```

## üìä Monitoring & Logging

### Application Logging
```typescript
// src/utils/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

export default logger;
```

### Health Checks
```typescript
// src/health/healthCheck.ts
export class HealthCheck {
  static async check(): Promise<HealthStatus> {
    return {
      status: 'healthy',
      timestamp: new Date(),
      services: {
        websocket: await this.checkWebSocket(),
        serial: await this.checkSerial(),
        led: await this.checkLED()
      }
    };
  }

  private static async checkWebSocket(): Promise<boolean> {
    // Check WebSocket server status
    return true;
  }

  private static async checkSerial(): Promise<boolean> {
    // Check serial communication
    return true;
  }

  private static async checkLED(): Promise<boolean> {
    // Check LED controller status
    return true;
  }
}
```

### Metrics Collection
```typescript
// src/metrics/metrics.ts
export class MetricsCollector {
  private static metrics = {
    messagesReceived: 0,
    messagesSent: 0,
    errors: 0,
    responseTime: [] as number[]
  };

  static recordMessageReceived(): void {
    this.metrics.messagesReceived++;
  }

  static recordMessageSent(): void {
    this.metrics.messagesSent++;
  }

  static recordError(): void {
    this.metrics.errors++;
  }

  static recordResponseTime(time: number): void {
    this.metrics.responseTime.push(time);
  }

  static getMetrics(): Metrics {
    return {
      ...this.metrics,
      averageResponseTime: this.calculateAverageResponseTime()
    };
  }

  private static calculateAverageResponseTime(): number {
    if (this.metrics.responseTime.length === 0) return 0;
    return this.metrics.responseTime.reduce((a, b) => a + b, 0) / this.metrics.responseTime.length;
  }
}
```

## üîß Configuration Management

### Environment Configuration
```typescript
// src/config/config.ts
export interface Config {
  port: number;
  serialPort: string;
  testMode: boolean;
  debug: boolean;
  batteryLevel: number;
  charging: boolean;
  logLevel: string;
}

export function loadConfig(): Config {
  return {
    port: parseInt(process.env.MOCK_PORT || '8080'),
    serialPort: process.env.MOCK_SERIAL_PORT || '/dev/ttyUSB0',
    testMode: process.env.MOCK_TEST_MODE === 'true',
    debug: process.env.MOCK_DEBUG === 'true',
    batteryLevel: parseInt(process.env.MOCK_BATTERY_LEVEL || '100'),
    charging: process.env.MOCK_CHARGING === 'true',
    logLevel: process.env.LOG_LEVEL || 'info'
  };
}
```

### Feature Flags
```typescript
// src/config/featureFlags.ts
export interface FeatureFlags {
  enableAdvancedLED: boolean;
  enableBatterySimulation: boolean;
  enableErrorRecovery: boolean;
  enablePerformanceMonitoring: boolean;
}

export const featureFlags: FeatureFlags = {
  enableAdvancedLED: process.env.ENABLE_ADVANCED_LED === 'true',
  enableBatterySimulation: process.env.ENABLE_BATTERY_SIMULATION === 'true',
  enableErrorRecovery: process.env.ENABLE_ERROR_RECOVERY === 'true',
  enablePerformanceMonitoring: process.env.ENABLE_PERFORMANCE_MONITORING === 'true'
};
```

## üö® Error Handling & Recovery

### Error Recovery Strategies
```typescript
// src/error/recovery.ts
export class ErrorRecovery {
  static async handleWebSocketError(error: Error): Promise<void> {
    logger.error('WebSocket error:', error);

    // Attempt to restart WebSocket server
    try {
      await wifiManager.restart();
      logger.info('WebSocket server restarted successfully');
    } catch (restartError) {
      logger.error('Failed to restart WebSocket server:', restartError);
      throw restartError;
    }
  }

  static async handleSerialError(error: Error): Promise<void> {
    logger.error('Serial communication error:', error);

    // Attempt to reconnect serial port
    try {
      await serialUtils.reconnect();
      logger.info('Serial port reconnected successfully');
    } catch (reconnectError) {
      logger.error('Failed to reconnect serial port:', reconnectError);
      throw reconnectError;
    }
  }
}
```

### Circuit Breaker Pattern
```typescript
// src/error/circuitBreaker.ts
export class CircuitBreaker {
  private failures = 0;
  private lastFailureTime = 0;
  private readonly threshold = 5;
  private readonly timeout = 60000; // 1 minute

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.isOpen()) {
      throw new Error('Circuit breaker is open');
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private isOpen(): boolean {
    return this.failures >= this.threshold &&
           Date.now() - this.lastFailureTime < this.timeout;
  }

  private onSuccess(): void {
    this.failures = 0;
  }

  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
  }
}
```

## üìà Performance Optimization

### Memory Management
```typescript
// src/performance/memoryManager.ts
export class MemoryManager {
  private static intervals: NodeJS.Timeout[] = [];

  static cleanup(): void {
    // Clear all intervals
    this.intervals.forEach(clearInterval);
    this.intervals = [];

    // Force garbage collection
    if (global.gc) {
      global.gc();
    }
  }

  static addInterval(interval: NodeJS.Timeout): void {
    this.intervals.push(interval);
  }

  static getMemoryUsage(): NodeJS.MemoryUsage {
    return process.memoryUsage();
  }
}
```

### Connection Pooling
```typescript
// src/performance/connectionPool.ts
export class ConnectionPool {
  private connections: WebSocket[] = [];
  private maxConnections = 10;

  async getConnection(): Promise<WebSocket> {
    if (this.connections.length < this.maxConnections) {
      const connection = await this.createConnection();
      this.connections.push(connection);
      return connection;
    }

    // Reuse existing connection
    return this.connections[0];
  }

  private async createConnection(): Promise<WebSocket> {
    // Create new WebSocket connection
    return new WebSocket('ws://localhost:8080');
  }
}
```

## üîê Security

### Input Validation
```typescript
// src/security/validation.ts
export class InputValidator {
  static validateMessage(message: any): boolean {
    if (!message || typeof message !== 'object') {
      return false;
    }

    if (!message.type || typeof message.type !== 'string') {
      return false;
    }

    if (!message.timestamp || typeof message.timestamp !== 'number') {
      return false;
    }

    return true;
  }

  static validateWiFiCredentials(credentials: any): boolean {
    if (!credentials || typeof credentials !== 'object') {
      return false;
    }

    if (!credentials.ssid || typeof credentials.ssid !== 'string') {
      return false;
    }

    if (!credentials.password || typeof credentials.password !== 'string') {
      return false;
    }

    return true;
  }
}
```

### Rate Limiting
```typescript
// src/security/rateLimiter.ts
export class RateLimiter {
  private requests = new Map<string, number[]>();
  private readonly limit = 100; // requests per minute
  private readonly window = 60000; // 1 minute

  isAllowed(clientId: string): boolean {
    const now = Date.now();
    const clientRequests = this.requests.get(clientId) || [];

    // Remove old requests
    const recentRequests = clientRequests.filter(
      time => now - time < this.window
    );

    if (recentRequests.length >= this.limit) {
      return false;
    }

    // Add current request
    recentRequests.push(now);
    this.requests.set(clientId, recentRequests);

    return true;
  }
}
```

---

**Note**: Ta strategia deployment zapewnia niezawodne wdro≈ºenie mocka urzƒÖdzenia z pe≈Çnym monitoringiem, logowaniem i obs≈ÇugƒÖ b≈Çƒôd√≥w.
