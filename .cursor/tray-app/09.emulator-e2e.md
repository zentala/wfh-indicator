# Emulator Integration with E2E Tests - Tray App

## 🎯 Cel Dokumentacji

Ten dokument opisuje jak mock urządzenia (`/emulator/`) integruje się z testami E2E w aplikacji tray-app, umożliwiając ukończenie zadań **Task 4.15** i **Task 6.7** bez potrzeby posiadania prawdziwego hardware.

## 📋 Obecny Status Testów E2E

### ✅ Wykonane Testy E2E
- **Task 2.8**: Test zmiany statusu w tray menu ✅
- **Konfiguracja**: Playwright + Vitest ✅

### ❌ Brakujące Testy E2E
- **Task 4.15**: Test E2E dla procesu parowania ❌
- **Task 6.7**: Test E2E dla "Ask to Enter" ❌

### 🔍 Problem z Testami E2E
**Główny problem:** Brak możliwości testowania komunikacji z urządzeniem
- Testy parowania wymagają symulacji urządzenia ESP32
- Testy "Ask to Enter" wymagają symulacji żądania od urządzenia
- Obecnie nie ma sposobu na testowanie komunikacji Serial/WiFi

## 🏗️ Architektura Integracji z Mockiem

### Struktura Testów E2E z Mockiem
```
tray-app/
├── e2e/
│   ├── device-mock/
│   │   ├── mock-server.ts      # Serwer mocka urządzenia
│   │   ├── mock-controller.ts  # API do kontrolowania mocka
│   │   └── mock-scenarios.ts   # Predefiniowane scenariusze
│   ├── tests/
│   │   ├── pairing.spec.ts     # Test parowania (Task 4.15)
│   │   ├── ask-to-enter.spec.ts # Test powiadomień (Task 6.7)
│   │   └── status-updates.spec.ts # Test aktualizacji statusu
│   └── utils/
│       └── mock-helper.ts      # Helpery do testów
```

### Mock Controller API
```typescript
// API do kontrolowania mocka w testach E2E
class MockDeviceController {
  // Symulacja przycisku fizycznego
  async pressButton(type: 'single' | 'long' | 'double'): Promise<void>;

  // Symulacja komunikacji szeregowej
  async receiveSerialData(data: WiFiCredentials): Promise<void>;

  // Symulacja żądania "Ask to Enter"
  async sendAskToEnterRequest(urgency: 'normal' | 'urgent'): Promise<void>;

  // Sprawdzenie stanu LED
  async getLEDStatus(): Promise<{ color: string; brightness: number }>;

  // Sprawdzenie ostatniej odpowiedzi
  async getLastResponse(): Promise<'yes' | 'no' | 'if_urgent'>;
}
```

## 📋 Scenariusze Testowe

### A. Test Parowania (Task 4.15)
```typescript
test('Complete pairing flow with mock device', async ({ page }) => {
  // 1. Otwórz kreator parowania
  await page.click('[data-testid="add-device"]');

  // 2. Mock odbiera SSID/password przez Serial
  await mockDevice.receiveSerialData({
    ssid: 'TestWiFi',
    password: 'test123'
  });

  // 3. Mock łączy się przez WiFi
  await mockDevice.connectToWiFi();

  // 4. Mock potwierdza parowanie (zielony LED)
  await mockDevice.confirmPairing();

  // 5. Sprawdź czy urządzenie pojawiło się na liście
  await expect(page.locator('[data-testid="device-list"]'))
    .toContainText('LED Device #1');
});
```

### B. Test "Ask to Enter" (Task 6.7)
```typescript
test('Ask to Enter notification flow', async ({ page }) => {
  // 1. Mock wysyła żądanie "Ask to Enter"
  await mockDevice.sendAskToEnterRequest({
    deviceId: 'device-1',
    urgency: 'normal'
  });

  // 2. Sprawdź czy powiadomienie się pojawiło
  await expect(page.locator('[data-testid="notification"]'))
    .toContainText('Ask to Enter');

  // 3. Kliknij "Yes" w powiadomieniu
  await page.click('[data-testid="notification-yes"]');

  // 4. Sprawdź czy odpowiedź została wysłana do mocka
  await expect(mockDevice.getLastResponse()).toBe('yes');
});
```

## 🔧 Implementacja Techniczna

### Mock w Trybie Testowym
```typescript
// emulator/src/main/deviceMock.ts
class DeviceMock {
  private testMode: boolean = false;
  private testController: TestController;

  constructor(options: { testMode?: boolean }) {
    this.testMode = options.testMode || false;
    if (this.testMode) {
      this.testController = new TestController();
    }
  }

  // API dla testów E2E
  async simulateButtonPress(type: 'single' | 'long' | 'double'): Promise<void> {
    if (!this.testMode) return;

    switch (type) {
      case 'single':
        await this.sendAskToEnterRequest('normal');
        break;
      case 'long':
        await this.enterPairingMode();
        break;
    }
  }
}
```

### Integracja z Playwright
```typescript
// tray-app/e2e/utils/mock-helper.ts
export class MockHelper {
  private mockController: MockDeviceController;

  async setupMock(): Promise<void> {
    // Uruchom mock urządzenia
    this.mockController = new MockDeviceController({
      port: 8080,
      serialPort: '/dev/ttyUSB0'
    });
    await this.mockController.start();
  }

  async simulateDeviceAction(action: DeviceAction): Promise<void> {
    switch (action.type) {
      case 'button_press':
        await this.mockController.pressButton(action.buttonType);
        break;
      case 'ask_to_enter':
        await this.mockController.sendAskToEnterRequest(action.urgency);
        break;
    }
  }
}
```

## 📋 Plan Implementacji

### Phase 1: Podstawowa Integracja (Sprint 4)
- [ ] Mock urządzenia z trybem testowym
- [ ] API do kontrolowania mocka
- [ ] Integracja z Playwright testami
- [ ] Podstawowe scenariusze testowe

### Phase 2: Zaawansowane Scenariusze (Sprint 5)
- [ ] Testy parowania z różnymi scenariuszami błędów
- [ ] Testy "Ask to Enter" z różnymi poziomami pilności
- [ ] Testy aktualizacji statusu w czasie rzeczywistym
- [ ] Testy obsługi błędów komunikacji

### Phase 3: Optymalizacja (Sprint 6)
- [ ] Automatyzacja uruchamiania mocka w CI/CD
- [ ] Parallel test execution z wieloma mockami
- [ ] Performance testing z symulacją wielu urządzeń

## 🎯 Korzyści z Integracji

1. **Realistyczne Testy** - Mock symuluje prawdziwe zachowanie urządzenia
2. **Kontrola Scenariuszy** - Możemy testować różne sytuacje (błędy, timeouty)
3. **Izolacja Testów** - Nie zależymy od prawdziwego hardware
4. **Szybkie Iteracje** - Testy działają bez fizycznego urządzenia
5. **CI/CD Friendly** - Mock może działać w środowisku CI/CD

## 🔗 Komunikacja z Tray App

### WebSocket Communication
```typescript
// Mock wysyła status do tray app
await mockDevice.sendStatusUpdate({
  type: 'status_update',
  status: WorkStatus.AVAILABLE,
  timestamp: Date.now()
});

// Mock odbiera status od tray app
mockDevice.onStatusUpdate((status: WorkStatus) => {
  this.ledController.setColor(status);
});
```

### Serial Communication (Pairing)
```typescript
// Mock odbiera dane WiFi podczas parowania
mockDevice.onSerialData((data: WiFiCredentials) => {
  this.wifiManager.connect(data.ssid, data.password);
});
```

## 📊 Metryki Sukcesu

### Technical Metrics
- **Test Coverage**: >90% dla funkcjonalności komunikacji z urządzeniem
- **Performance**: <100ms response time dla status updates
- **Reliability**: 99.9% uptime podczas sesji testowych
- **Compatibility**: Działa z obecną tray app bez modyfikacji

### Development Metrics
- **Code Quality**: ESLint score >95%
- **Documentation**: JSDoc coverage dla wszystkich publicznych API
- **Maintainability**: Jasne oddzielenie odpowiedzialności, modularny design

## 🚀 Następne Kroki

### Sprint 4 (Priorytet)
1. **Implementacja mocka urządzenia** - podstawowa funkcjonalność
2. **Integracja z testami E2E** - Task 4.15
3. **Testy parowania** - pełny przepływ

### Sprint 5 (Planowany)
1. **Testy "Ask to Enter"** - Task 6.7
2. **Zaawansowane scenariusze** - błędy, timeouty
3. **Optymalizacja wydajności** - parallel execution

### Sprint 6 (Planowany)
1. **CI/CD integration** - automatyzacja uruchamiania mocka
2. **Performance testing** - symulacja wielu urządzeń
3. **Dokumentacja** - przykłady użycia i API reference

## 🔧 Konfiguracja Środowiska

### Wymagania
- Node.js 18+
- pnpm
- TypeScript 5.2+
- Playwright

### Instalacja
```bash
# W folderze emulator
cd emulator
pnpm install

# W folderze tray-app
cd ../tray-app
pnpm install
```

### Uruchamianie Testów
```bash
# Uruchom mock urządzenia
cd emulator
pnpm start:mock

# W nowym terminalu, uruchom testy E2E
cd tray-app
pnpm test:e2e
```

## 📝 Uwagi dla Programistów

### Ważne Uwagi
1. **Mock musi być uruchomiony** przed testami E2E
2. **Porty muszą być wolne** - mock używa portu 8080 dla WebSocket
3. **Tryb testowy** - mock ma specjalny tryb dla testów E2E
4. **Izolacja testów** - każdy test powinien resetować stan mocka

### Debugging
```typescript
// Włącz debug mode w mocku
const mockDevice = new MockDeviceController({
  debug: true,
  port: 8080
});

// Sprawdź logi mocka
mockDevice.onLog((message: string) => {
  console.log(`[Mock] ${message}`);
});
```

---

**Note**: Ta integracja umożliwia ukończenie wszystkich testów E2E w tray-app bez potrzeby posiadania prawdziwego hardware, jednocześnie zapewniając realistyczne testowanie komunikacji z urządzeniem.
