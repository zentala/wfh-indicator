# Analiza problemów z testami w projekcie WFH Indicator (Tray App)

Ten dokument podsumowuje zidentyfikowane problemy z konfiguracją i uruchamianiem testów, opisuje podjęte próby naprawy oraz ich rezultaty.

## 1. Główne Zidentyfikowane Problemy

### 1.1. Konflikt Runnerów: Vitest vs. Playwright

-   **Problem**: Główny skrypt `npm test` uruchamia `vitest`. Domyślnie `vitest` próbuje uruchomić *wszystkie* pliki `*.spec.ts`, w tym testy E2E z katalogu `e2e/`, które są napisane dla Playwright.
-   **Skutek**: Powoduje to błąd `Error: Playwright Test did not expect test() to be called here`, ponieważ `vitest` nie wie, jak interpretować składnię Playwright.

### 1.2. Błędy Mockowania Modułów i Hoisting

-   **Problem**: `vi.mock` w `vitest` jest "hoistowane", czyli przenoszone na samą górę pliku przed wykonaniem importów. Powodowało to błędy `ReferenceError`, gdy mock próbował użyć klasy lub zmiennej zdefiniowanej w tym samym pliku, która jeszcze nie istniała.
-   **Skutek**:
    -   `deviceManager.test.ts`: Błąd `ReferenceError: Cannot access 'SerialPortStub' before initialization`.
    -   `scheduleService.test.ts`: Błąd `TypeError: deviceManager.on is not a function`, ponieważ mock `deviceManager` był prostym obiektem bez metod `EventEmitter`.

### 1.3. Błędy w Testach Komponentów React (React Testing Library)

-   **Problem**: Testy komponentów nie uwzględniały asynchronicznej natury Reacta. Operacje powodujące aktualizację stanu (np. kliknięcie przycisku, które wywołuje zapytanie API) nie były opakowane w `act()`.
-   **Skutek**: Ostrzeżenia `An update to ... was not wrapped in act(...)` i potencjalnie niestabilne testy, które mogły kończyć się niepowodzeniem, ponieważ asercje były wykonywane, zanim komponent zakończył renderowanie.
-   **Problem 2**: Brakujące implementacje w `jsdom` (środowisku testowym), np. `window.alert`.
-   **Skutek 2**: Błąd `Error: Not implemented: window.alert`.

### 1.4. Brak Izolacji Testów

-   **Problem**: Testy dla `deviceManager` nie były od siebie odizolowane. Ponieważ `deviceManager` jest singletonem, jego wewnętrzny stan (np. tablica `this.devices`) był współdzielony między testami. Jeden test mógł dodać urządzenie, a następny nieoczekiwanie znajdował je w stanie początkowym.
-   **Skutek**: Nieprzewidywalne i trudne do debugowania błędy w testach, które zależały od kolejności wykonania.

## 2. Podjęte Próby Naprawy i Ich Rezultaty

### Podejście 1: Poprawa Mocków (Częściowo udane)

-   **Działanie**:
    1.  W `deviceManager.test.ts` próbowałem naprawić mockowanie `SerialPort`, tworząc klasę-zaślepkę (`SerialPortStub`).
    2.  W `scheduleService.test.ts` rozszerzyłem mock `deviceManager` o `EventEmitter`.
    3.  W `WifiConfigStep.test.tsx` dodałem mock `window.alert`.
    4.  W `DevicesTab.test.tsx` i `AutoStatusTab.test.tsx` zaktualizowałem selektory (np. na `data-testid`) i opakowałem operacje w `act()`.
-   **Rezultat**: To rozwiązało problemy z `act()` i `window.alert`, ale problemy z hoistingiem (`ReferenceError`) pozostały, ponieważ podejście do `SerialPortStub` było błędne.

### Podejście 2: Konfiguracja Vitest - `exclude` (Nieudane)

-   **Działanie**: Zmodyfikowałem `vite.config.ts`, dodając regułę `exclude: ["e2e/**"]`, aby jawnie kazać `vitest` ignorować katalog z testami E2E.
-   **Rezultat**: Z niejasnych przyczyn ta konfiguracja spowodowała, że `vitest` zaczął ignorować *wszystkie* pliki testowe, co skutkowało wynikiem `Test Files 0 passed`.

### Podejście 3: Konfiguracja Vitest - `include` (Nieudane)

-   **Działanie**: Zmieniłem strategię w `vite.config.ts` – zamiast `exclude`, użyłem `include: ["src/**/*.{test,spec}.{ts,tsx}"]`, aby jawnie wskazać, które testy ma uruchamiać.
-   **Rezultat**: Niestety, to również nie przyniosło oczekiwanego skutku. Problem z `vitest` uruchamiającym testy Playwrighta powrócił, co sugeruje, że moja konfiguracja `vite` jest gdzieś fundamentalnie błędna lub w konflikcie z inną częścią projektu (np. Electron Forge).

### Podejście 4: Poprawione Mockowanie z Użyciem Fabryki (Ostatnia próba)

-   **Działanie**: Wróciłem do problemu z `ReferenceError` w `deviceManager.test.ts`. Zastosowałem bardziej zaawansowaną technikę, używając "fabryki" w `vi.mock`, która dynamicznie tworzy i zwraca klasę-zaślepkę. To powinno ostatecznie rozwiązać problem z hoistingiem.
-   **Rezultat**: To jest ostatnia zmiana, którą wprowadziłem. Logi pokazują, że nadal mamy błędy, więc to podejście również zawiodło w obecnej konfiguracji.

### Podejście 5: Reset Konfiguracji `vite.config.ts` (Nieudane)

-   **Działanie**: Zgodnie z planem, zresetowałem `vite.config.ts` do minimalnej, domyślnej postaci, usuwając całą sekcję `test`. Teoretycznie `vitest` powinien był użyć swoich domyślnych ustawień.
-   **Rezultat**: Testy zakończyły się niepowodzeniem, a logi pokazały, że `vitest` ponownie próbował uruchomić testy E2E (`e2e/app.spec.ts`, `e2e/tray-status.spec.ts`), co spowodowało błąd `Playwright Test did not expect test() to be called here`. Dodatkowo, powrócił błąd `ReferenceError` w `scheduleService.test.ts`, ponieważ bez konfiguracji `setupFiles` mocki nie były poprawnie ładowane.

### Podejście 6: Restrukturyzacja Konfiguracji Vite (Częściowo udane)

-   **Działanie**:
    1.  Zgodnie ze znalezionym przykładem, podzieliłem `vite.config.ts` na trzy osobne pliki: `vite.main.config.ts`, `vite.preload.config.ts`, i `vite.renderer.config.ts`.
    2.  Stworzyłem `forge.config.ts`, aby wskazać Electron Forge, gdzie szukać tych plików.
    3.  Przeniosłem całą konfigurację `vitest` do `vite.renderer.config.ts`.
    4.  Usunąłem stary `vite.config.ts`.
-   **Rezultat**: To podejście również początkowo zawiodło, ponieważ skrypt `npm test` nie wiedział, którego pliku konfiguracyjnego Vite użyć.

### Podejście 7: Jawne Wskazanie Konfiguracji i Ostateczna Naprawa (Sukces!)

-   **Działanie**:
    1.  Zmodyfikowałem skrypt `test` w `package.json` na `"test": "vitest --config ./vite.renderer.config.ts"`, aby jawnie wskazać `vitest`, której konfiguracji ma użyć.
    2.  Stworzyłem brakujący plik `src/test/setup.ts`.
    3.  Użyłem precyzyjnej reguły `exclude: ["e2e/**/*.{test,spec}.{ts,tsx}"]` w `vite.renderer.config.ts`.
    4.  Poprawiłem błąd `ReferenceError` w `scheduleService.test.ts`, używając fabryki w `vi.mock` do dynamicznego mockowania `deviceManager`.
-   **Rezultat**: **SUKCES!** To ostatecznie rozwiązało konflikt runnerów. `Vitest` teraz poprawnie uruchamia tylko testy jednostkowe i ignoruje katalog `e2e`. Błędy z Playwrightem zniknęły.

## 3. Aktualny Stan i Pozostałe Problemy (20.07.2025)

Po udanej restrukturyzacji konfiguracji, pozostały nam następujące problemy, wszystkie w obrębie `scheduleService.test.ts`:

1.  **`MaxListenersExceededWarning`**: W konsoli pojawia się ostrzeżenie o możliwym wycieku pamięci w `EventEmitter`. Dzieje się tak, ponieważ w każdym teście tworzona jest nowa instancja `ScheduleService`, która subskrybuje się do zdarzeń globalnego singletona `deviceManager`. Listenery nie są usuwane po zakończeniu testu.
2.  **3 Nieprzechodzące Testy**: Mimo poprawnego uruchomienia, 3 testy w `scheduleService.test.ts` nadal kończą się niepowodzeniem.

**Następne kroki:**

1.  ~~Naprawić `MaxListenersExceededWarning`, implementując czyszczenie listenerów w `afterEach` w `scheduleService.test.ts`.~~ **(Zrobione)**
2.  ~~Zdiagnozować i naprawić 3 pozostałe błędy w testach `scheduleService`.~~ **(Zrobione)**

## 4. Ostateczne Rozwiązanie i Status (20.07.2025)

Po wielu iteracjach, wszystkie problemy z testami jednostkowymi zostały rozwiązane.

-   **Konflikt Vitest/Playwright**: Rozwiązany przez podział konfiguracji Vite na osobne pliki (`vite.renderer.config.ts` itd.) i jawne wskazanie jej w skrypcie `npm test`.
-   **Wyciek Pamięci (`MaxListenersExceededWarning`)**: Rozwiązany przez dodanie metody `destroy()` do `ScheduleService` i jej wywołanie w `afterEach` w teście, co zapewnia czyszczenie listenerów `EventEmitter`.
-   **Błędy w Testach `scheduleService`**:
    -   Problem z asynchronicznością i `vi.useFakeTimers()` został naprawiony.
    -   Błąd w szpiegowaniu zdarzeń został rozwiązany przez zmianę techniki z `service.on('event', spy)` na `vi.spyOn(service, 'emit')`. To zapewniło, że testy mogły poprawnie weryfikować argumenty emitowanych zdarzeń.

**Wszystkie testy jednostkowe (`*.test.ts`, `*.test.tsx`) w projekcie przechodzą pomyślnie.**

Testy E2E (`e2e/*.spec.ts`) są teraz poprawnie ignorowane przez runner testów jednostkowych i mogą być uruchamiane osobno za pomocą Playwright.
